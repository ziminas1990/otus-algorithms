# Homework #11: Hash Tables
## Комментарии к коду
Логика хэш-таблицы реализована в шаблонном классе **HashTable**. Данный класс имеет следующие шаблонные параметры:
  - Key - тип ключа;
  - Value - тип хранимого значения;
  - lSlidingSize - определяет, нужно ли изменять количество корзин:
    - если количество элементов вдвое превысило количество корзин, то таблица перестраивается, удваивая количество корзин;
    - если количество козин втрое превышает количество элементов, то таблица перестраивается, уменьшая количество корзин в два раза;
  - eBucketsPolicy - определяет, какие корзины использовать:
    - eListBucketsOnly - только корзины реализованные как список;
    - eAVLBucketsOnly  - только корзины, реализованные на базе AVL-деревьев;
    - eMixedBuckets - использовать карзины на базе списков, но если их длина превысила пороговое значение, то заменять её на корзину на базе AVL-дерева;
  - Hash - хэш-функция для ключа.
  
Таким образом, изменяя параметры шаблона, можно изменять поведение хэш-таблицы, что позволяет протестировать её производительность на различных комбинациях параметров *lSlidingSize* и *eBucketsPolicy*.

Для того, чтобы можно было изменять тип корзины "на лету", HasTable не должен зависеть от реализации конкретной корзины, поэтому он зависит от интерфейса **IBucket** - интерфейс для корзины. Класс IBucket имеет два наследника:
  - **ListBucket** - реализация корзины на базе списка;
  - **AVLTreeBucket** - реализация корзины на базе AVL-дерева.
  
И завершу комментарии коротким обзором по наиболее интересным функциям класса HashTable.
  - **insert()/get()/remove()** - вставка/получение/удаление элемента;
  - **getBucketId()** - преобразование ключа в номер корзины (остаток от деленя хэша на количество корзин);
  - **getOrCreateBucket()** - выдаёт корзину, соответствующую некоторому ключу, **но** если корзины нет, то **создаёт** её, причём тип новой корзины зависит от значения шаблонного параметра eBucketsPolicy;
  - **resize()** - перестраивает всю хэш-таблицу с новым количество корзин; количество корзин передаётся как параметр и может быть больше текущего количества корзин, а может быть и меньше; функция **не имеет эффекта**, если lSlidingSize = false;
  - **replaceBucket()** - заменяет корзину одного типа (список) на корзину другого типа (AVL-дерево); **не имеет эффекта**, если eBucketsPolicy != eMixedBuckets.
  
## Автотесты
Логика теста реализована в функции **TestHashTable()**. Она выполняет следующее:
  - вставляет N элементов в случайной последовательности;
  - проверяет, что все элементы доступны по ключу и имеют корректное значение;
  - удаляет N/2 произвольных элементов;
  - проверяет, что ни один из удалённых элементов больше не доступен по ключу, а не удалённые элементы по прежнему доступны и имеют корректное значение.
Значение N передаётся как параметр.

Функция **runHashTableTests()** запускает тест *TestHashTable()* для хэш-таблиц со всеми возможными комбинациями lSliding и eBucketsPolicy, чтобы убедится, что во всех случаях таблица работает корректно.

## Сравнение производительности
В рамках данной домашней работы не стояло задачи провести сравнение производительности, поэтому я решил скэономить время и использовать его чтобы догнать группу. Однако, в приложении всё же сравнил скорость выполнения процедуры **TestHashTable** для разных хэш-таблиц для 300.000 элементов и получил такие результаты:

| lSlidingSize   | eBucketsPolicy | Attempt #1 | Attempt #2 | Attempt #3 | Attempt #4 |
|----------------|----------------|------------|------------|------------|------------|
| false (fixed)  | ListBuckets    | 71803      | 77609      | 77225      | 78795      |
| false (fixed)  | MixedBuckets   | 793        | 829        | 860        | 849        |
| false (fixed)  | AVLBuckets     | 869        | 898        | 910        | 928        |
| true (sliding) | ListBuckets    | 758        | 767        | 792        | 793        |
| true (sliding) | MixedBuckets   | 836        | 826        | 861        | 878        |
| true (sliding) | AVLBuckets     | 554        | 549        | 564        | 586        |

**Вывод:** действительно плохие показатели демонстрирует только хэш-таблица с фиксированным количеством корзин, реализованных как список. Во всех остальных случаях производительность увеличивается либо за счёт увеличение количества корзин, либо за счёт использования корзин на базе AVL-деревьев, либо то и другое. Лучшие результаты показывает хэш-таблица с изменяемым количеством корзин, реализованных на базе AVL-деревьев. Однако очевидного фаворита указать нельзя.
