# Homework #17: Heap Manager
## Описание приложения
В рамках задачи был реализован класс **AwesomeHeap**. Класс реализует управление кучей: аллокацию и освобождение участков памяти произвольного размера.  
При создании объекта класса нужно указать:
  - размер кучи;
  - политику поиска подходящего фрагмента.
  
Всего AwesomeHeap поддерживает 3 разных политики:
  - **eFirst** - использует первый найденный фрагмент памяти подходящего размера;
  - **eBest** - использует самый маленький фрагмент памяти, вмещающий указанный объём данных;
  - **eWorst** - использует самый большой фрагмент памяти.

Менеджер реализован следующим образом:\\
изначально куча представляет из себя один большой (размером со всю кучу) свободный Chunk. В заголовке Chunk'а распологается два указателя: на следующий Chunk и на предыдущий Chunk. Но это **не совсем** связный список, т.к. Chunk'и располагаются в памяти непосредственно друг за другом.  
Когда требуется **выделить** некоторый объём памяти из кучи, менеджер выполняет следующие действия:
  1. ищет подходящий Chunk (согласно указанной политике);
  2. помечает chunk как занятый;
  3. отступает от чанка требуемое количество байт (выравненное по 8) и на оставшейся от исходного chunk'а памяти создаёт новый свободный chunk.
Когда требуется **освободить** некоторый участок памяти, менеджер выполняет следующие действия:
  1. получает указатель на chunk, которому принадлежит память (за O(1));
  2. помечает chunk как свободный;
  3. если chunk, следующий за освобождённым, помечен как свободный, то присоединяется к текущему чанку;
  4. если предыдущий chunk помечен как свободный, то текущий чанк присоединяется к нему.
  
 Таким образом, если в куче никогда не будет существовать два последовательно идущих друг за другом свободных чанка - они будут объединятся в один, более крупный.
 
 ## Тестирование работы AweomeHeap
 Для проверки корректности работы AwesomeHeap в main.cpp был реалиован тест **Test()**. Логику теста достаточно подробно описал в комментарии к коду, поэтому не вижу смысла здесь её дублировать. Могу лишь отметить, что тест осуществляет множество выделений и освобождений памяти случайным образом и проверяет, что при этом менеджер памяти не выдал блоки, которые бы пересекались друг с другом.  
 
 ## Сравнение фрагментации и производительности для разных политик
 На базе теста Test() было проведено сравнение фрагментации и производительности AwesomeHeap при использовании разных политик.
 Результаты теста опубликовал в виде красивых графиков в google docs: [HW-17-Heap-Manager](https://docs.google.com/spreadsheets/d/19XK6a7a0GRHI84NOxD0WsdQVqNiVFSQOYbg3qVRnCwg/edit?usp=sharing) (графики загружаются не сразу)  
 
 Чтобы оценивать фрагментацию памяти, в AwesomeHeap была добавлена статистика. В статистику входят лишь два поля:
   * количество свободных чанков;
   * количество заняты чанков.
 Очевидно, что чем меньше свободных чанков присутствует в куче, тем ниже фрагментация памяти. В идеале, должен быть лишь один свободнй чанк. Поэтому за степень фрагментации было решено взять **отношение** свободных чанков к занятым чанкам. Чем выше это значение, тем выше уровень фрагментации.
 
 В процессе прогона теста, каждые 100 итераций выводится текущий уровень фрагментации. По этим значениям и был построен график, ссылку на который я дал выше.
 
## Выводы
С точки зрения **фрагментации** памяти, наилучшей политикой можно считать политику **eBest**, которая отдаёт пользователю самый маленький чанк, в которые влезает требуемый объём данных.
  
С точки зрения **скорости работы**, наиболее эффективной оказалась политика **eFirst**, т.к. в отличие от политик eBest и eWorst, для того чтобы найти чанк не обязательно просматривать все чанки, достаточно дойти до первого достаточно большого чанка и вернуть его пользователю.

Политика **eWorst** оказалась хуже двух других по всем показателям. При такой политике возникает самая высокая фрагментация памяти. При этом, чем выше фрагментация памяти, тем больше чанков расположено на куче, а значит тем дольше времени требуется на просмотр чанков, из-за чего быстродействие кучи с такой политикой оказывается хуже, чем с политикой eBest.
