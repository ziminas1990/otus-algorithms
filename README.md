
# ДЗ #5: Сортировка Шелла

Приложение принимает единственный аргумент - размер массива. Формирует случайный массив и запускает для него сортировку следующими алгоритмами:
  * сортировка вставкой;
  * сортировка Шелла с коэффициентами Шелла; ожидаемая сложность - O(N^2);
  * сортировка Шелла с коэффициентами Хиббарда; ожидаемая сложность - O(N^(3/2));
  * сортировка Шелла с коэффициентами Седвига; ожидаемая сложность - O(N^(4/3)).

Для **частично** отсортированных массивов эксперименты не проводились.

## Таблица производительности
Сортировка вставками:

| Алгоритм                     | 1000 | 2000 | 4000 | 6000 | 8000 | 10000 | 15000 | 20000 | 40000 | 70000 |
|------------------------------|------|------|------|------|------|-------|-------|-------|-------|-------|
| Сортировка вставками         | 2    | 12   | 47   | 96   | 171  | 267   | 600   | 1076  | 4324  | 13149 |

Сортировка Шелла:

| Алгоритм                     |  35к | 70к | 140к | 280к | 560к | 800к | 1000к | 1200к | 1400к  | 1600к | 2000к |
|------------------------------|------|-----|------|------|------|------|-------|-------|--------|-------|-------|
| Шелл (коэффициенты Шелла)    |  35  | 80  | 172  | 378  | 950  | 1616 | 1999  | 2463  | 2858   | 3935  | 4528  |
| Шелл (коэффициенты Хиббарда) |  31  | 73  | 163  | 381  | 899  | 1325 | 1772  | 2322  | 2779   | 3380  | 4243  |
| Шелл (коэффициенты Седвига)  |  28  | 62  | 130  | 289  | 611  | 930  | 1161  | 1482  | 1733   | 1995  | 2573  |

## Выводы
Классический алгоритм вставками работает очень медленно, катастрофически проигрывая алгоритму Шелла. На 70000 элементов разница более чем в 160 раз.
Вероятно, что несмотря на схожую сложность O(N^2), алгоритм вставками имеет намного худшие коэффициенты, чем алгоритм Шелла, из-за чего и проигрывает в скорости.

Сравнивая алгоритм Шелла на разных коэффициентах было замечено, что:
  - **коэффициенты Шелла** являются наименее эффективными из рассмотренных;
  - **коэффициентры Хиббарда** работают несколько быстрее, чем коэффициенты Шелла, но незначительно;
  - **коэффициенты Седвига** стабильно показывает существенно лучшие результаты чем два предыдущих варианта.

## Комментарии к коду
Для реализации алгоритмов над обычным C-массивом была реализована обёртка Array<T>. Она позволяет задать смещение и шаг и учитывает их, когда алгоритм запрашивает i-ый элемент. Используя этот класс, можно реализовать алгоритм вставками, а потом переиспользовать его в алгоритме Шелла. И код самих сортировок становится намного проще, т.к. нет возни с индексами, отступами и проч.
 
Обзор функций (в порядке их определения):
  - **insert_sort** - сортировка вставками, принимающая массив Array<T>; переиспользуется в shell_sort();
  - **insert_sort_q** - аналогична inset_sort, но работает с обычным C-массивом; она используется для оценки скорости работы алгоритма, чтобы в оценку не попали накладные расходы, которые добавляет Array<T>;
   - **shell_sort** - реализация алгоритма сортировки Шелла для произвольного набора коэффициентов;
   - **ShellsCoefficients** - генерирует коэффициенты Шелла;
   - **HibbardCoefficients** - генерирует коэффициенты Хиббарда;
   - **SedgewickCoefficients** - генерирует коэффициенты Седвига;
   - **checkSortedArray** - функция проверяет, что массив отсортирован; испольщуется в тестах;
   - **TestInsertSort** - тестирование функции insert_sort;
   - **TestShellSort** - тестирование функции shell_sort для коэффициентов Шелла;
 
 Программа при запуске принимает единственный аргумент - длина массива, который необходимо сгенерировать и отсортировать. Выводит время работы разных алгоритмов для массива указанной длины. Например
 ```
$ ./Sorting 70000
insert_sort: 13149 ms (correct)
shell_sort (Shells): 75 ms (correct)
shell_sort (Hibbard): 68 ms (correct)
shell_sort (Sedgewick): 62 ms (correct)
 ```
