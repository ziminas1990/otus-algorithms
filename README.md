# Homework #14: Алгоритм Крускала
## Описание приложения
Приложение находит на указанном графе минимальное остовое дерево используя алгоритм Крускала.
Пример работы приложения: [example.svg](https://github.com/ziminas1990/otus-algorithms/blob/hw-14-Kruskal/example.svg). На графе приложение подсветило красным те рёбра, которые составляют минимальное остовое дерево для данного графа.

Приложение имеет 2 параметра:
```
Demucron <file> [dot]
```
  - \<file\> - файл с описанием графа в формате, предусмотренным заданием;
  - dot - если параметр указан (его значение совпадает с его именем), то приложение выдаст на выход не список ребёр (как предусмотрено заданием), а описание графа в формате GraphViz, где рёбра минимального остового дерева окрашены в красный цвет (остальные - в чёрный);
  
Пусть есть следующий входной файл **в формате, описанным в задании** (example.txt):
```
0 1 3 4 0 0 4 0 0
1 0 0 0 2 2 0 0 4
3 0 0 5 2 0 2 4 0
4 0 5 0 0 0 2 0 0
0 2 2 0 0 3 0 3 0
0 2 0 0 3 0 0 0 3
4 0 2 2 0 0 0 0 0
0 0 4 0 3 0 0 0 3
0 4 0 0 0 3 0 3 0
```
Если запустим приложение, указав только файл, то получим список рёбер, которые составляют минимальное остовое дерево. Т.е. вывод **соответствует требованию задания**:
```
$ ./Kruskal ./example.txt
```
```
0 -- 1
1 -- 4
1 -- 5
2 -- 4
2 -- 6
3 -- 6
4 -- 7
5 -- 8
```

Если запустим приложение, указав не только файл, но и дополнительную опцию "dot", то приложение сгенерирует описание графа в формате GraphViz, подсветив красным те рёбра, которые составляют минимальное остовое дерево:
```
./Kruskal ./example.txt dot
```
```
digraph G {
  0 -> 1 [dir = none, label = 1, len = 1, color = "#FF0000"]
  0 -> 2 [dir = none, label = 3, len = 3, color = "#000000"]
  0 -> 3 [dir = none, label = 4, len = 4, color = "#000000"]
  0 -> 6 [dir = none, label = 4, len = 4, color = "#000000"]
  1 -> 4 [dir = none, label = 2, len = 2, color = "#FF0000"]
  1 -> 5 [dir = none, label = 2, len = 2, color = "#FF0000"]
  1 -> 8 [dir = none, label = 4, len = 4, color = "#000000"]
  2 -> 3 [dir = none, label = 5, len = 5, color = "#000000"]
  2 -> 4 [dir = none, label = 2, len = 2, color = "#FF0000"]
  2 -> 6 [dir = none, label = 2, len = 2, color = "#FF0000"]
  2 -> 7 [dir = none, label = 4, len = 4, color = "#000000"]
  3 -> 6 [dir = none, label = 2, len = 2, color = "#FF0000"]
  4 -> 5 [dir = none, label = 3, len = 3, color = "#000000"]
  4 -> 7 [dir = none, label = 3, len = 3, color = "#FF0000"]
  5 -> 8 [dir = none, label = 3, len = 3, color = "#FF0000"]
  7 -> 8 [dir = none, label = 3, len = 3, color = "#000000"]
}
```

Текст в формате graphviz можно преобразовать в картинку графа используя, утилиту **neato**. Например, на сайте [GraphViz Online](https://dreampuf.github.io/GraphvizOnline).
Выданное приложением описание графа преобразуется в [example.svg](https://github.com/ziminas1990/otus-algorithms/blob/hw-14-Kruskal/example.svg)

## Комментарии к коду
Алгоритм реализован в файле Kruskal.h как функция
```
static void kruskal(std::vector<Edge> allEdges, size_t nTotalNodes,
                    std::vector<Edge>& minSpanTreeEdges)
```
Алгоритм использует класс **NodesClusters**, которые реализует следующие операции:
  - **find()** - определение номера кластера, которому принадлежит некоторый узел;
  - **newCluster()** - создание нового кластера из двух вершин, не входящих ни в один другой кластер;
  - **addNodeToCluster()** - добавляет к указанному кластеру узел, не принадлежащий ни одному из других кластеров;
  - **mergeClusters()** - объединяет два кластера в один, т.е. переносит все элементы из кластера с бОшьним номером в кластер с меньшим номером.

Алгоритм крускала принимает на вход:
  - **allEdges** - вектор всех рёбер графа;
  - **nTotalNodes** - общее количество вершин графа;
  - **minSpanTreeEdges** - ссылка пустой вектор рёбер, в который будут записаны рёбра минимального остового дерева.

Ребро представлено структурой **Edge**, которая хранит в себе инцедентные ему узлы и его вес.

Для представления графа в памяти был выбран подход, именуемый как "Матрица Индцендентности". Этот подход реализован в виде класса **AdjancencyMatrixGraph** (см. одноимённый h-файл).  
Интерфейс **IGraph** был перенесён из прошлой домашней работы, но упрощён (убрал из него лишнее) + было добавлен интерфейс **IWeightedGraph**, который расширяет интерфейс **IGraph** дополнительными методами, позволяющими работать с рёбрами и их весами. Эти интерфейсы не были слиты в один, т.к. код для генерации graphviz-текста по прежнему требует только интерфейс IGraph.
