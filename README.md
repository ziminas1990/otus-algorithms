# Homework #13: Demucron Algorithm
## Пример работы
Граф ДО топологической сортировки: [example_before.svg](https://github.com/ziminas1990/otus-algorithms/blob/hw-13-Demucron/example_before.svg)  
Граф ПОСЛЕ топологический сортировки: [example_after.svg](https://github.com/ziminas1990/otus-algorithms/blob/hw-13-Demucron/example_after.svg)

## Описание приложения
Приложение имеет 2 необязательных параметра:
```
Demucron [<file>] [dot]
```
  - \<file\> - файл с описанием графа в формате, предусмотренным заданием;
  - dot - если параметр указан (его значение совпадает с его именем), то приложение выдаст на выход не список уровней (как предусмотрено заданием), а описание графа в формате GraphViz с указанием уровней узлов
  
Пусть есть следующий входной файл **в формате, описанным в задании** (example.txt):
```
5 2 6
6 8 7
1
5 2 7
0 1
1
8
8
```
Этому файлу соответствует следующий граф: [example_before.svg](https://github.com/ziminas1990/otus-algorithms/blob/hw-13-Demucron/example_before.svg)

Если запустим приложение, указав только файл, то получим список уровней (первый столбец) и список узлов, на каждом уровне. Т.е. вывод **соответствует требованию задания**.
```
$ ./Demucron ./example.txt
```
```
0	 3 4
1	 0
2	 5 2
3	 1
4	 6 7
5	 8
```

Если запустим приложение, указав не только файл, но и дополнительную опцию "dot", то приложение сгенерит граф в формате GraphViz:
```
./Demucron ./example.txt dot
```
```
digraph G {
  0 [label = "0", color = "#A0A0A0", style = filled];
  1 [label = "5", color = "#A0A0A0", style = filled];
  2 [label = "2", color = "#A0A0A0", style = filled];
  3 [label = "6", color = "#A0A0A0", style = filled];
  4 [label = "1", color = "#A0A0A0", style = filled];
  5 [label = "8", color = "#A0A0A0", style = filled];
  6 [label = "7", color = "#A0A0A0", style = filled];
  7 [label = "3", color = "#A0A0A0", style = filled];
  8 [label = "4", color = "#A0A0A0", style = filled];

  { rank = same; 7; 8; }
  { rank = same; 0; }
  { rank = same; 1; 2; }
  { rank = same; 4; }
  { rank = same; 3; 6; }
  { rank = same; 5; }

  0 -> 1, 2, 3;
  1 -> 4;
  2 -> 4;
  3 -> 5;
  4 -> 3, 5, 6;
  5;
  6 -> 5;
  7 -> 1, 2, 6;
  8 -> 0, 4;
}
```

Текст в формате graphviz можно преобразовать в картинку графа используя, утилиту **dot**. Например, на сайте [GraphViz Online](https://dreampuf.github.io/GraphvizOnline).  
Выданное приложением описание графа преобразуется в [граф после топологический сортировки (example_after.svg)](https://github.com/ziminas1990/otus-algorithms/blob/hw-13-Demucron/example_after.svg)

## Комментарии к коду
Для того, чтобы реализация алгоритма Демукрона (как и Косараю в прошлой домашней работе) не зависела от способа представления графа в памяти, был введён интерфейс **IGraph** (см. файл *IGraph.h*). С помощью данного интерфейса можно исследовать связи в графе. Каждому узлу графа выдаётся его уникальный идентификатор (IGraph::NodeId), который *может не совпадать* с именем узла. Например, узел с именем "1" вполне может иметь идентификатор NodeId = 4. Наследники класса IGraph, как и реализуемые алгоритмы, работают **только** с NodeId.

Для того, чтобы хранить информацию об именах узлов, цвете каждого узла (в данной ДЗ не используется) и уровне узлов, был создан класс **GraphData**, который является наследником интерфейса **IGraphData** (см. файл *GraphData.h*).

В данной домашней работе используется представление графа как набора векторов смежности. Это представление реализовано в классе **AdjancencyVectorGraph**, который является наследником IGraph (см фай. *AdjancencyVectorGraph.h*).

При считывании графа из файла, одновременно заполняются как наследник *IGraph*, так и наследник *IGraphData* (смю функцию buildGraph() в main.cpp).

Алгоритм Демукрона реализован в файле *Demucron.h* в виде функции:
```
IGraphData::Levels demucron(IGraph const& graph)
```
Функция принимает информацию о структуре графа и возвращает массив уровней, где каждый уровень описывается массивом узлов, которые его составляют (как этого требует задание).

В файлах **DotGenerator.h** и **DotGenerator.cpp** реализована логика формирования описания графа в формате GraphViz.

В файле **Utils.h** реализованы вспомогательные функции, которые используются в разных домашних работах.
