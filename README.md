# Homework #11: Kosaraja Algorithm

На вход программе подаётся файл с описанием графа ([example.txt](https://github.com/ziminas1990/otus-algorithms/blob/hw-12-Kosaraio/example.txt)):
```
A B
B E F C
C D G
D C H
E A F
F G
G F
H D G
```

Первый элемент каждой строки - имя некоторого узла графа, а последующие - это перечисление всех смежных с ним узлов.

Задача приложения - найти в исходном графе компоненты сильной связности, т.е. такие подграфы, все элементы которых сильно связаны между собой (из любого узла можно дойти до любого другого узла подграфа). Каждому найденному подграфу назначается некоторый случайный цвет и все узлы данного подграфа раскрашиваются в этот цвет.

На выходе программа выдаёт описание графа в формате [graphviz](https://www.graphviz.org/), которое можно преобразовать в наглядную картинку с помощью, например, таких утилит как *dot* или *neato* (можно сделать это online на [Graphviz Online](https://dreampuf.github.io/GraphvizOnline)).

Например, для приведённого выше описания исходного графа программа сгенерирует следующий текст:
```
digraph G {
    
  graph [rankdir="LR"]
    
  0 [label = "A", color = "#D4668B", style = filled];
  1 [label = "B", color = "#D4668B", style = filled];
  2 [label = "E", color = "#D4668B", style = filled];
  3 [label = "F", color = "#90E3CF", style = filled];
  4 [label = "C", color = "#539ADF", style = filled];
  5 [label = "D", color = "#539ADF", style = filled];
  6 [label = "G", color = "#90E3CF", style = filled];
  7 [label = "H", color = "#539ADF", style = filled];


  0 -> 1;
  1 -> 2, 3, 4;
  2 -> 0, 3;
  3 -> 6;
  4 -> 5, 6;
  5 -> 4, 7;
  6 -> 3;
  7 -> 5, 6;
}
```

И в виде изображения: [example.svg](https://github.com/ziminas1990/otus-algorithms/blob/hw-12-Kosaraio/example.svg)

Более интересный пример:  
Входные данные: [example_2.txt](https://github.com/ziminas1990/otus-algorithms/blob/hw-12-Kosaraio/example_2.txt)  
Результат (уже в виде изображения): [example_2.svg](https://github.com/ziminas1990/otus-algorithms/blob/hw-12-Kosaraio/example_2.svg)  

## Комментарии к коду
Для того, чтобы реализация алгоритма Косараю не зависела от способа представления графа в памяти, был введён интерфейс **IGraph** (см. файл **IGraph.h**). С помощью данного интерфейса можно исследовать связи в графе. Каждому узлу графа выдаётся его уникальный идентификатор (IGraph::NodeId), который **может не совпадать** с именем узла. Например, узел с именем "1" вполне может иметь идентификатор NodeId = 4. Наследники класса IGraph, как и реализуемые алгоритмы, работают **только** с NodeId.

Для того, чтобы хранить информацию об именах узлов и цвете каждого узла, был создан класс **GraphData**, который является наследником интерфейса **IGraphData** (см. файл **GraphData.h**).

В данной домашней работе используется представление графа как набора векторов смежности. Это представление реализовано в классе **AdjancencyVectorGraph**, который является наследником IGraph (см. файл **AdjancencyVectorGraph.h**).

При считывании графа из файла, одновременно заполняются как наследник *IGraph*, так и наследник *IGraphData* (см. функцию **buildGraph()** в main.cpp).

Алгоритм Касараю реализован в файле **Kosaraja.h** в виде функции:
```
void kosaraja(IGraph const& graph, Clusters& clusters)
```
Функция принимает информацию о структуре графа и возвращает через ссылку *clusters* массив кластеров (или компонент высокой связности), где каждый кластер описывается массивом узлов, которые его составляют.

В файлах **DotGenerator.h** и **DotGenerator.cpp** реализована логика формирования описания графа в формате GraphViz.

В файле **Utils.h** реализованы вспомогательные функции, которые используются в разных домашних работах.
