# ДЗ #6: Heap Sort
Таблица производительности для реализованного алгоритма:

| Алгоритм  | 50к | 100к | 200к | 400к | 800к | 1600к | 3200к | 6400к | 12800к |
|-----------|-----|------|------|------|------|-------|-------|-------|--------|
| Heap sort |  38 | 80   | 173  | 368  | 824  | 1835  | 4124  | 9307  | 20545  |

Как видно, с ростом объёма входных данных время выполнение растёт **немного быстрее** чем линейно.

### Комментарии к коду
Для бОльшей читаемости кода процедур, вся работа с массивом как с деревом была вынесена в класс BinaryTreeNode, который является обёрткой над массивом.

Функции (в порядке их определения):
  * drown() - реализует алгоритм "утопления" корневого элемента в дереве;
  * buildHeapTree() - строит на произвольном массиве корректный heap tree;
  * heapSort() - реализует алгоритм heap sort на некотором массиве;
  * checkHeapTree() - проверяет heap tree на корректность;
  * TestBuildHeapTree() - функция, тестирующая работу алгоритма buildHeapTree();
  * TestHeapSort() - функция, тестирующая работу алгоритма сортировки heapSort().
  
 Если запустить приложение без параметров, то оно запускает тестирование своих алгоритмов и завершает работу.
 
 Приложению можно передать единственный параметр - размер массива. При этом, приложение создаст массив указанного размера, отсортирует его и выведет время, потраченное на сортировку, а так же корректность полученного массива после сортировки.
